##1.如下代码
```java
 public class Alpha{
         public void foo(){
                System.out.print("Afoo ");
           }
｝
     public class Beta extends Alpha{
          public void foo() {
                 System.out.print("Bfoo" );
           }
    public static void main(String[] args){
           Alpha a = new Beta();
           Beta b=(Beta)a;
           a.foo();
           b.foo();
      }
｝
```
下面哪一个是正确的（）

A.Afoo Afoo

B. Afoo Bfoo

C. Bfoo Afoo

D. Bfoo Bfoo

E. Compilation fails

F.An exception is thrown at runtime

答案:D

考察多态性，编译器认为a是Alpha 类型，b 是Beta 类型，但是虚拟机知道a 和b 的真实类型是Beta，所以调用Beta 类的函数。

## 2.下列哪种说法是正确的（ ）
A． 实例方法可直接调用超类的实例方法

B． 实例方法可直接调用超类的类方法

C． 实例方法可直接调用其他类的实例方法

D． 实例方法可直接调用本类的类方法

答案 D

解析:
AC选项 如果方法是private 则不可以;
B选项类父类的类方法是属于父类本身的;
D选项虽然类方法可以类名.类方法来调用 但是new 该类 的实例方法去调也不不会报错 ;
记住一句话：实例方法只能直接调用本类的方法，其他类的方法得需要引用调用

## 3.
```java
public class Test {
    public final String a;
        public Test() {
            a = "10";
        }
    public void setA1(){
               a = "20";
        }
     public static void main(String[] args) {
            Test t = new Test();
            t.setA1();
            System.out.println(t.a);
        }
}
```
t.a的值为（）

A “10”

B “20”

C “”

D 以上都不对，并且编译错误

答案 D
解析 ：因为a被final（只能在初始化时赋值一次，一旦被赋值后，就不能再更改了，习惯上常量名使用全大写）修饰了，所以在setA1中再次赋值了，直接导致编译错误。
## 4.面向对象的特征有哪些方面?()
A:抽象;

B:继承;

C:多态;

D:封装;

答：面向对象的特征主要有以下几个方面：

1)抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

2)继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。

3)封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。

4)多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

## 5.下列关于继承的哪项叙述是正确的？
A 在java中允许多继承

B 在java中一个类只能实现一个接口

C 在java中一个类不能同时继承一个类和实现一个接口

D java的单一继承使代码更可靠

答案：D

解析：
A：Java只能单继承。所以A选项错误
B：Java中一个类可以实现多个接口，所以B错误
C：Java中一个类只能实现继承一个父类但是可以同时实现多个接口，所以C错误
D：Java的单一继承使代码更可靠，是正确的。

## 5.（多选）1.下列说法中正确的是？（）
A：子类能继承父类的构造方法；

B：子类对从父类继承来的成员的访问权限，取决于父类成员声明的访问权限；

C：子类不能删除从父类继承来的成员变量；

D：在子类的实例成员中方法中，可使用“super引用”访问被子类隐藏的父类同名成员变量；

答案：CD

解析：

A错误，子类不能继承父类的构造方法，子类能够继承除父类的构造方法外的成员变量和成员方法。

B错误，子类对从父类继承来的成员的访问权限，取决于父类成员的声明的访问权限。子类能够访问父类的公有和保护成员，不能访问父类的私有成员。
C正确，子类不能删除从父类继承来的成员。当从父类继承来的成员不能满足子类需求时，子类不能删除他们。可以重定义他们，修改或扩充父类成员方法的功能，使父类成员能够适应子类新的需求。
D正确，在子类的实例成员方法中，可使用“super引用”访问被子隐藏的父类同名成员变量，调用被子类覆盖的父类同名成员方法，语法格式如下：
super.成员变量 //当子类隐藏父类成员变量时，引用父类同名成员变量super.成员方法（参数列表） //当子类覆盖父类成员方法时，调用父类同名成员变量
super将当前对象作为其父类的一个实例引用。 注意：静态方法中不能使用super引用。

## 6.多态分为几种情况，分别是哪几种情况？（）
A：2种，调用时的多态和编译时的多态。

B：2种，编译时多态和运行时的多态。

C：2种，运行时的多态和调用时的多态。

D：3种，调用时的多态、运行时的多态和编译时的多态。

答案：B
解析：
多态分为两种情况，分别是编译时的多态和运行时的多态。
如果在编译时能够确定执行多态方法中哪一个，则称为编译时的多态；否则，称为运行时的多态。

## 7.类有几种访问权限？变量和方法有几种访问权限？
A.1 2

B.2 2

C.2 4

D.4 4

答案：C

解析：
类有两种访问权限：public，友好的。
方法和变量的访问权限：public，protected，友好的，private。
public：公有的，任何类都可以访问。
protected：受保护的，同一个包的类可以访问。不同包的子类可以访问。
友好的：同一个包的类可以访问。
private：私有的，在同一个类中才能访问。
## 8.一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？
  A. 值传递
  
  B. 引用传递
  
答案：A
 
  解析：Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的 
## 9.Java 多态的优缺点分别是什么？
 答：多态的优点：
 
 提高了代码的维护性（继承保证）；
 
 提高了代码的扩展性（由多态保证）；
 
 多态的缺点：
 不能使用子类的特有功能（非要使用只能通过不优雅的创建子类对象方式，但是占用内存，其次就是使用强转类型，也容易出现问题）；
 向下转型（把父类转换为子类型）中有可能会出现异常； 
## 10.Java 常见的内部类有哪几种，简单说说其特征？
 答：静态内部类、成员内部类、方法内部类（局部内部类）、匿名内部类。
 
 静态内部类是定义在另一个类里面用 static 修饰 class 的类，静态内部类不需要依赖于外部类（与类的静态成员属性类似）且无法使用其外部类的非 static 属性或方法（因为在没有外部类对象的情况下可以直接创建静态内部类的对象，如果允许访问外部类的非 static 属性或者方法就会产生矛盾）。
 
 成员内部类是没有用 static 修饰且定义在在外部类类体中的类，是最普通的内部类，可以看做是外部类的成员，可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员），而外部类无法直接访问成员内部类的成员和属性，要想访问必须得先创建一个成员内部类的对象然后通过指向这个对象的引用来访问；当成员内部类拥有和外部类同名的成员变量或者方法时会发生隐藏现象（即默认情况下访问的是成员内部类的成员，如果要访问外部类的同名成员需要通过 OutClass.this.XXX 形式访问）；成员内部类的 class 前面可以有 private 等修饰符存在。
 
 方法内部类（局部内部类）是定义在一个方法里面的类，和成员内部类的区别在于方法内部类的访问仅限于方法内；方法内部类就像是方法里面的一个局部变量一样，所以其类 class 前面是不能有 public、protected、private、static 修饰符的，也不可以在此方法外对其实例化使用。
 
 匿名内部类是一种没有构造器的类（实质是继承类或实现接口的子类匿名对象），由于没有构造器所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调，匿名内部类在编译的时候由系统自动起名为 OutClass$1.class，一般匿名内部类用于继承其他类或实现接口且不需要增加额外方法的场景（只是对继承方法的实现或是重写）；匿名内部类的 class 前面不能有 pravite 等修饰符和 static 修饰符；匿名内部类访问外部类的成员属性时外部类的成员属性需要添加 final 修饰（1.8 开始可以不用）。
 
 ##8.下面关于Java类的构造方法的说法中正确的是：（ ）   
 A. 一个类至少有一个构造方法
 
 B. 构造方法的返回值类型必须是void
 
 C. 构造方法的可见性修饰符必须是public
 
 D. 构造方法必须显式的定义
 
 正确答案: A
 解析：
 构造方法是一种特殊的方法：它必须具备和所在类相同的名字；没有返回值类型，甚至连void也没有；构造方法是在创建一个对象使用new操作符时调用的，作用是初始化对象。
 造方法可以默认提供而不显式定义。
 简单的说就是，每个类至少有一个构造方法，即使没有写出来，即可以不用显示定义。她没有返回值，连void都没有，但是也可以使用private修饰构造方法。

##9.为什么构造方法里 this 或者 super 函数调用必须放在第一行且无法共存？
 答：super 方法在构造函数的第一行原因是子类有可能访问了父类对象，比如在构造函数中使用父类对象的成员函数和变量，在成员初始化使用了父类，在代码块中使用了父类等，所以放在第一行可以保证在子类可以访问父类对象之前完成对父类对象的初始化。
 
 this 方法在构造函数的第一行原因是为保证父类对象初始化的唯一性，因为假设类 B 是类 A 的子类，如果 this 方法可以在构造函数的任意行使用则首先程序运行到构造函数 B() 的第一行发现没有调用 this() 和 super()，就自动在第一行补齐了 super() 方法（这是 java 默认的机制），以此完成了对父类对象的初始化，然后返回子类的构造函数继续执行，当运行到构造函数 B() 的 this(参数) 调用行时, 调用 B 类对象的另一个构造方法 B(参数)，在 B(参数) 中还会对父类对象再次初始化，这就造成了对资源的浪费，也有可能造成某些意想不到的结果，所以 this 方法不能出现在构造方法除第一行以外的其他行。
 
 这也就解释了为啥在构造方法里面 this 与 super 方法不能同时存在的原因。   
 
 ## 10.Java 构造方法能否被重写和重载？
 答：重写是子类方法重写父类的方法，重写的方法名不变，而类的构造方法名必须与类名一致，假设父类的构造方法如果能够被子类重写则子类类名必须与父类类名一致才行，所以 Java 的构造方法是不能被重写的。而重载是针对同一个的，所以构造方法可以被重载。
 ## 11.Java 创建对象的方式有哪几种？
 有4种显式地创建对象的方式：
 
 1.用new语句创建对象，这是最常用的创建对象的方式。
 
 2.运用反射手段，调用Java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
 
 3.调用对象的clone()方法。
 
 4.运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法.
 
 ## 12.Which two demonstrate a ?has a” relationship(Choose two)?()
 ```java
A. public interface Person { }
public class Employee extends Person{ }

B. public interface Shape { }
public interface Rectandle extends Shape { }

C. public interface Colorable { }
public class Shape implements Colorable
{ }

D. public class Species{ }
public class Animal{private Species species;}

E. interface Component{ }
class Container implements Component{
private Component[] children;
}
```
 答案：D
 解析：
 “has a”是关联关系，关联分双向关联和单向关联，双向关联是A，B类分别持有对方的引用(有是对方的属性).
 单向关联是一方持另一方的引用.
 
 ##13.Given the folowing classes which of the following will compile without error?()
 ```java
     ObRef ob = new ObRef();
        Base b = new Base();
        Object o1 = new Object();
        IFace o2 = new CFace();
        o1=o2;
        b=ob;
        //ob=b;
        o1=b;
        System.out.println(o1);
```
 A. o1=o2;
 
 B. b=ob;
 
 C. ob=b;
 
 D. o1=b;
 
 答案：B
 解析：
 b和ob对应的类之间没有任何关系，要想b=ob成立要么是父子关系，要么是接口实现类的关系。实际测试结果是只有c不能通过其他都可以
 
 ```java
class Person { 
    private int a;
    public int change(int m){return m;} 
}

public class Teacher extends Person{ 
    public int b;
    public static void main(String arg[]){ 
        Person p = new Person(); 
        Teacher t = new Teacher(); 
        int i; 
        // point x 
    }
}
```

A， i = m;

B， i = b;

C， i = p.a;

D， i = p.change(3);

E， i = t.b;
答案：D
【解析】本题考查类的声明。选项A中m没有被声明过，不能使用；选项B中虽然b是类Teacher的public成员变量，但在静态方法中，不能使用类中的非静态成员；选项C中a是类Person的private成员，在类外不能直接引用；选项D中change(intm)方法是pubtic方法，并且返回一个int型值，可以通过类的实例变量P引用并赋值给一个int型变量。

##14.下面那几个函数是public void method(){̷}的重载函数？（）
A.public void method( int m){̷}

B.public int method(){̷}

C.public void method2(){̷}

D.public int method(int m，float f ){̷}

答案：A D
解析：
重载就是方法名一样(必须的)，里面执行的内容不一样，但是呢，又出现一个问题，你写的两个或者多个方法要能让JVM(JAVA 虚拟机)认识是唯一的，所以，这里就和返回的类型无关了，因为如果返回类型不一样，其他都一样的话，那JVM是不知道到底是调用哪个方法的。所以方法名一样，入参的类型，个数，顺序（术语：方法的签名）只要有一个不同就是方法的重载了。
## 15.Java 匿名内部类在使用时如何初始化的？
匿名内部类无法通过构造方法初始化，所以我们只能通过构造代码块进行初始化。
## 16.开发中使用 Java 匿名内部类有哪些注意事项
答：常见的注意事项如下。

使用匿名内部类时必须是继承一个类或实现一个接口（二者不可兼得且只能继承一个类或者实现一个接口）。

匿名内部类中是不能定义构造函数的，如需初始化可以通过构造代码块处理。

匿名内部类中不能存在任何的静态成员变量和静态方法。

匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。

匿名内部类不能是抽象类，必须要实现继承的类或者实现接口的所有抽象方法。








 