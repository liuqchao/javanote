##1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。
## 2.在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？
lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。
## 3.关于sleep()和wait()，以下描述错误的一项是（ ）
A. sleep是线程类（Thread）的方法，wait是Object类的方法；

B. sleep不释放对象锁，wait放弃对象锁；

C. sleep暂停线程、但监控状态仍然保持，结束后会自动恢复；

D. wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态。

解答：D

解析：
sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

##4.（多选）下面能让线程停止执行的有( )
A. sleep();

B. stop();

C. notify();

D. synchronized();

E. yield();

F. wait();

G. notifyAll();

答案：ABDEF

解析：
sleep：导致此线程暂停执行指定时间
stop: 这个方法将终止所有未结束的方法，包括run方法。
synchronized():对象锁
yield：当前正在被服务的线程可能觉得cpu的服务质量不够好，于是提前退出，这就是yield。
wait：当前正在被服务的线程需要睡一会，醒来后继续被服务

##5.多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作该数据的部分改为 ()
A:类型定义机制;

B:数据封装机制;

C:类型定义机制和数据封装机制

D:上述都不对;

答案: A
解析：
对该数据加锁，放在同步代码块中

synchronize(){
}

